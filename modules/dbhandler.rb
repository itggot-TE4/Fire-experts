class Input

    # Public: turns an array containing values and array of keys into a hash
    # 
    # array: the array containing values
    # array: the array containing keys
    # 
    # Examples
    # 
    # Input.array_to_hash(["string1", "string2"], ["key2", "key1"])
    #   #=> {"key2" => "string1", "key1" => "string2"}
    def self.array_to_hash(array, keys)
        
        # special case, 'id' is autogenerated by database
        if keys[0] == "id"
            
            keys.shift
            
        end
        
        hash ={}
        
        keys.each_with_index do |column, i|
            
            hash[column] = array[i]
            
        end
        
        # puts '#----------#'
        # puts ''
        # p hash
        # puts ''
        # puts '#----------#'
        
        return hash
        
    end

    # Public: turns and array or hash-keys into a string for use in an sql statement
    # 
    # list: the array or hash to be turned into a string
    # 
    # Examples
    # 
    # Input.list_to_string(["hello", "I", "am", "an", "example"])
    #   #=> "'hello', 'I', 'am', 'an', 'example'"
    def self.list_to_string(list)
        
        output = ""
        
        if list.is_a? Array
            
            # handle cases where an array containing an array has been input
            if list[0].is_a? Array
            
                list = list[0]
                
            end

            list.each_with_index do |element, i|
                
                    output += "'#{element}'"
                
                if list.length > i + 1
                    
                    output += ", "
                    
                end
                
            end
            
            return output
            
        elsif list.is_a? Hash
            
            keys = list.keys
            
            array = []
            
            keys.each do |key|
                
                array << list[key]
                
            end
            
            list_to_string(array)
            
        else
            
            puts '#---------------------#'
            puts 'error in list_to_string'
            puts "this shouldnt happen"
            puts '#---------------------#'
            
        end
        
    end

end

class DBhandler < Input
    
    @table_name = nil
    @column_names = nil
    
    # Public: checks if a databse is connected and connects one if false
    # 
    # Examples
    # 
    # DBhandler.connect
    #   #=> @db
    def self.connect
        
        @db ||= SQLite3::Database.new('db/db.db')
        @db.results_as_hash = true
        @db
        
    end
    
    # Public: gets values from database
    # 
    # Examples
    # 
    # DBhandler.get do {:columns => "*", :nondefault_table => "Example"}
    #   #=> all items in table "Example"
    def self.get(&blk)
        
        connect
        
        input = yield
        
        if input[:fragment] == nil
            
            input[:fragment] = ""
            
        end
        
        if input[:nondefault_table]
            
            @db.execute("SELECT #{input[:columns]} FROM #{input[:nondefault_table]} #{input[:fragment]}", input[:condition]) 
            
        else
            
            @db.execute("SELECT #{input[:columns]} FROM #{@table_name} #{input[:fragment]}", input[:condition]) 
            
        end
    end
    
    # Public: gets all values from a table
    # 
    # Examples
    # 
    # Class_inheriting_DBhandler.get_all do {} end
    #   #=> all the values in the database table corresponding to the class variable @table_name
    def self.get_all(&blk)
        
        connect
        
        input = yield
        
        @db.execute("SELECT * FROM #{@table_name} #{input[:fragment]}", input[:condition])
        
    end
    
    # Public: gets all items from a table where a condition is fullfilled
    # 
    # Examples
    # 
    # Class_inheriting_DBhandler.get_all_where do {:where => "bananpaj", :condition => "god"}
    #   #=> all the values in the database table corresponding to the class variable @table_name where "banapaj" = "god"
    def self.get_all_where(&blk)
        
        connect
        
        input = yield
        
        get_all do {:fragment => "WHERE #{input[:where]} = ?", :condition => input[:condition]} end
        
    end
    
    # Public: inserts a series of values into a database
    # 
    # Examples
    # 
    # Class_inheriting_DBhandler.insert do {:insertion => {"bananpaj" => "god"}} end
    #   #=> "god" has been inserted into column "bananpaj" on table @table_name
    def self.insert(&blk)
        
        connect
        
        input = yield
        
        columns = Input.list_to_string(input[:insertion].keys)
        
        values = Input.list_to_string(input[:insertion])
        
        # puts '------'
        # puts ''
        # p columns
        # puts ''
        # puts '------'
        # puts ''
        # p values
        # puts ''
        # puts '------'
        
        if input[:nondefault_table] != nil
            
            @db.execute("INSERT INTO #{input[:nondefault_table]} (#{columns}) VALUES (#{values})")
            
        else
            
            @db.execute("INSERT INTO #{@table_name} (#{columns}) VALUES (#{values})")
            
        end
        
    end
    
    # Public: updates values in a database
    # 
    # Examples
    # 
    # Class_inheriting_DBhandler.update do {:columns => ["bananpaj", kanelbulle], :values => ["inte god", "god"], :where => "id", :condition => 1} end
    #   #=> values in table @table_name where "id" = 1 in columns "bananpaj" and "kanelbulle" have been updated to "inte god" and "god" respectively
    def self.update(&blk)
        
        input = yield
        
        connect
        
        if input[:columns].length == input[:values].length
            
            input[:columns].each_with_index do |column, i|
                
                @db.execute("UPDATE #{@table_name} SET #{column} = '#{input[:values][i]}' WHERE #{input[:where]} = ? ", input[:condition])
                
            end
            
        end
        
    end
    
    # Public: checks if a username is unique
    # 
    # Examples
    # 
    # User.unique? do {:username => "not_unique_name"} end
    #   #=> false
    def self.unique?(&blk)
        
        input = yield
        
        name_taken = false
        
        taken_names = get do {:columns => "full_name"} end
        
        taken_names.each do |name|
            
            if name["full_name"] == input[:full_name]
                
                return false
                
            end
            
        end
        
        return true
        
    end
    
end

class Fork < DBhandler
    
    @table_name = "forks"
    
    @column_names = ["full_name", "comment", "graded", "parent_repo"]
    
    #Checks if there already is a comment for the given fork, and then either creates a new comment or updates the existing one
    def self.save_comment(&blk) 
        
        input = yield
        
        if unique? do {:full_name => input[:full_name]} end
            
            insert do {:insertion => array_to_hash([input[:full_name], input[:comment], input[:graded], input[:parent_repo]], @column_names)} end
            
        else 
            
            update do {:columns => ["comment", "graded"], :values => [input[:comment], input[:graded]], :where => "full_name", :condition => input[:full_name]} end
            
        end
        
    end
    
end